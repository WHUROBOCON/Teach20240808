***
# 程序说明  
## 栈  
*  该程序调用stdio库和stdlib库，以实现栈的存放。
* 全程序采用了较多的指针来实现调用功能。
*   采用链表结构进行编写，故在开头先定义结点和栈，然后进行结点和栈的初始化。
* 主从函数构成，主函数主要调用入栈、出栈、返回栈顶三个功能，并输出了运行效果。
* 从函数有四个，分别是入栈函数、出栈函数、栈顶返回函数和判断栈是否为空的函数。
## 队列
* 同样调用stdio库和stdlib库，实现队列的存放。
* 同样使用了较多指针访问。
* 采用数组结构进行编写，数组内存占用较小，但是无法实现间断储存数据，不适合动态储存。
* 主函数相比栈（上面写的），可以再多实现循环的功能，即循环队列，用以连续入队或者出队。
* 从函数和栈的定义大同小异，只是换了个壳子。  
***  
# 学习记录
## 指针  
~~一下一些内容比较主观，刘备瞎写一写，看一乐~~
* 概要：  
指针可以说是c语言的灵魂所在。大一上学的c语言有点太浅了，结构体和指针都没有好好的讲过，所以其实到今天之前，刘备不太理解，为什么说c是在和底层硬件打交道甚至于觉得指针名不副实，被虚吹了。愚蠢的刘备。刘备接下来嗦点自己的理解，其他一些比较理论的东西网上讲的比刘备好多了，就不班门弄斧了。
>* 理解：  
指针和内存是割不开的两个东西，存储在内存中的数据有自己的地址，所写程序可以通过调用指针通过地址来间接访问数据。  
很抽象对吧，确实，没事，一点点来。  把这个关节打通，之后的栈和队列都不成问题。  
uu们知道指南针吗？就是掏出来，就会自动指北的东西   ~~请忽略对地磁北极的执念~~ 指针也是一样的，当你掏出指针的时候，指针自动指向一个方向，顺着这个方向走，就会看到在尽头存放的东西，这个就是实际存在内存里的东西，而指针相当于给了你一个地址，让你按图索骥。  
我们的数据实际上是被按所占字节大小，塞进了内存里，等着我们去用它，而指针就相当于把地图某个地方的宝箱位置告诉了你，想要寻宝，就按地址去找就好了。  
这时候可能就有人问了，啊，那我们直接把调用的值拷贝一份不就好了，干嘛弯弯绕绕的，麻烦死了。是这样的，如果是“a”“b“”c“这样占用空间很小的东西，你复制一下去直接用，这也无妨。但是，如果是一组数据呢？一个二维数组或者体量更大的东西，难道要把它们全都粘下来吗？你愿意这么干，内存可不愿意了，你们之间的二人世界太过拥挤，已经塞不下第三者了。这时候，采用指针，只存数据的首地址，就可以极大的节省空间。  
所以，数组其实是指针的一种，只不过被用的太多了，所以单独拎出来了。
* 用途：  
传参  
传返回值，可实现多返回值，也可传给`main`函数句柄，甚至可以对文件进行直接操作，狠狠拿捏住了。  
单片机应用，应该会是之后电控组的重点，还可讲数据转为字节，便于通信。  
## 栈和队列  
### 链表 
本质上是一种非连续的数组，同一类数据会被链接起来，按结点来判断储存。但同时，每个结点会保存下一个结点的地址，内存占用相对纯数组而言大一些，但是更适合动态储存和删除。  推荐采用带头结点的链表。
### 双向循环链表  
* 循环链表：在单链表的基础上，把尾结点的后继指向头结点，实现循环。   
弊端：当需要获取某个结点时，需要历遍前驱所有结点，很麻烦。 
* 双向循环链表：在结点的指针域里多添加一个`pre`指针，以实现双向循环。  
* [具体实现](https://blog.csdn.net/AAMahone/article/details/81059994)
```  
bool GetElem(int &e,int i,DoubleLinkedList L)   //获取结点;
{
    while(L != NULL && i > 0)
    {
        i--;
        L = L->next;
    }
    if(i == 0 && L != NULL)
    {
        e = L->data;
        return true;
    }
    else return false;
}

bool InsertElem(int e,int i,DoubleLinkedList L)    //插入结点;
{
    if(i > L->data+1 || i < 1)
        return false;
    else
    {
        L->data++;
        while(i > 1)
        {
            L = L->next;
            i--;
        }
        DoubleLinkedList Temp = (DoubleLinkedList)malloc(sizeof(LNode));
        Temp->data = e;
        if(L->next != NULL)
        {
            Temp->next = L->next;
            Temp->pre = L;
            L->next->pre = Temp;
            L->next = Temp;
        }
        else
        {
            Temp->pre = L;
            L->next = Temp;
            Temp->next = NULL;
        }
    }
}
 
bool DeleteElem(int i,DoubleLinkedList L)   //删除结点;
{
    if(i > L->data || i < 1)
        return false;
    else
    {
        L->data--;
        while(i > 1)
        {
            L = L->next;
            i--;
        }
        DoubleLinkedList Temp = (DoubleLinkedList)malloc(sizeof(LNode));
        Temp = L->next;
        if(L->next->next != NULL)
        {
            L->next->next->pre = L;
            L->next = L->next->next;
        }
        else
            L->next = NULL;
        free(Temp);
        Temp = NULL;
        return true;
    }
}

   
```
  
### 栈和队列的区别
* 栈是一种LIFO型数据结构，后进先出；而队列是一种FIFO型数据结构，先进先出。  
* 栈采用头插法，而队列采用链表的头尾插入。  
* 顺序栈可以实现多栈空间共享，但顺序队列不行。  
* 队列可实现循环操作。  
### 栈的构建思路  
栈要实现入栈、出栈、返回栈顶三大功能。要出栈入栈，首先要看栈空不空/满不满，因此，要写一个判断函数，防止溢出或报错；就是怎么去实现功能，我们采用链表的头插法，则栈顶其实就是链表的头结点，好的，到现在为止已经明确了要用到什么结构了，一个是链式结构，一个是栈，所以要在开头定义和初始化一下；如果要入栈，则需先把栈顶赋给下一个结点，再把结点赋给栈顶，因为栈的里多存了个数据，所以要给栈扩大一些；出栈同理。返回栈栈顶调用一个判断函数再返回即可。  （具体代码实现不赘述）
### 队列构建思路  
相比于栈，构建思路基本相同，来讲讲差别。  
队列是FIFO型，所以采用的头尾法插入，入队原有的队尾插入即可。  
循环队列，通过一下实现  
```for (int i = 0; i < 10; ++i) { queue_enqueue(&queue, (float) i); }
  for (int i = 0; i < 10; ++i) {
    float temp;
    queue_dequeue(&queue, &temp);
    printf("%f\n", temp);  }
```  




  
  
 